# /implement - Build Approved Spec

Execute an approved spec with TDD methodology and automatic agent routing.

## Usage

```bash
/implement                       # Build the approved spec
/implement --task=T001           # Run single task
/implement --task=T001,T002,T003 # Run specific tasks
/implement --task=T001-T005      # Run task range
/implement --phase=1             # Run phase 1 only
/implement --phase=1,2           # Run phases 1 and 2
/implement --phase=2+            # Run phase 2 onwards
/implement --resume              # Continue from checkpoint
```

---

## Flags

| Flag      | Description               | Example     |
| --------- | ------------------------- | ----------- |
| --task=ID | Execute specific task(s)  | --task=T001 |
| --phase=N | Execute specific phase(s) | --phase=2   |
| --resume  | Resume from checkpoint    | --resume    |

**Filter Precedence:** --task > --phase (most specific wins). --resume is orthogonal (controls starting point, combinable with either filter).

---

## MANDATORY: Preview and Agent Delegation

> **STOP. Before executing /implement, you MUST:**
>
> 1. **Show preview** - Display the execution plan (see Preview section below)
> 2. **Get confirmation** - Use AskUserQuestion tool to confirm Run/Cancel
> 3. **Load agent file** - Read the appropriate agent file based on routing:
>    - Backend → `.claude/agents/code-agent.md`
>    - Frontend → `.claude/agents/ui-agent.md`
>    - Docs → `.claude/agents/docs-agent.md`
>    - Evals → `.claude/agents/eval-agent.md`
> 4. **Follow CRITICAL EXECUTION REQUIREMENT** - Found in the agent file
> 5. **Use Task tool** - Spawn sub-agents for each phase, NEVER execute directly
>
> **If you skip the preview or execute tools directly, you are doing it wrong.**

---

## Task Tool Examples

### Spawn Code Researcher

```typescript
Task({
  subagent_type: "general-purpose",
  description: "Research backend for [feature]",
  prompt: `You are a code-researcher sub-agent.

TASK: Research existing patterns for [feature]
SPEC: ${specPath}
SUMMARY: ${summary_from_summary_md} // Passed from summary.md if available

STEPS:
1. Read the spec files
2. Search for existing implementations
3. Check for naming conflicts
4. Identify patterns to follow

OUTPUT FORMAT:
{
  "decision": "PROCEED | STOP | CLARIFY",
  "context_summary": "max 500 tokens for writer",
  "patterns_found": [...],
  "conflicts": [...]
}

Use Read, Grep, Glob, mcp__cclsp__* tools.`,
  model: "opus",
});
```

### Spawn Code Writer (TDD)

```typescript
Task({
  subagent_type: "general-purpose",
  description: "Implement backend for [feature]",
  prompt: `You are a code-writer sub-agent.

TASK: Implement backend for [feature] using TDD
SPEC: ${specPath}tasks.md
CONTEXT: ${research_summary}

TDD WORKFLOW (MANDATORY):
1. RED: Write failing test first
2. GREEN: Minimal code to pass
3. REFACTOR: Clean up while green

For each task in tasks.md:
1. Write test
2. Run test (must fail)
3. Implement
4. Run test (must pass)
5. Mark task [x] complete

Use Edit, Write, Bash tools.
Return: { "files_changed": [...], "context_summary": "..." }`,
  model: "sonnet",
});
```

### Spawn Code Validator

```typescript
Task({
  subagent_type: "general-purpose",
  description: "Validate implementation",
  prompt: `You are a code-validator sub-agent.

TASK: Validate the implementation
FILES_CHANGED: ${files_changed}

RUN THESE CHECKS:
1. pnpm typecheck
2. pnpm test:run
3. pnpm lint
4. Check for security issues

Return: { "passed": true/false, "issues": [...] }`,
  model: "haiku",
});
```

---

## Examples

```bash
/implement    # Build whatever spec was approved via /design
```

## Prerequisites

- Must have an approved spec from `/design`
- If no spec exists, you'll be prompted to run `/design` first
- Optional: `spec.json` enhances routing and task data (auto-generated by `/design`)
- Optional: `summary.md` provides quick context summary (auto-generated by `/design`)

## What Happens

1. **Resolve spec path** - Use spec-resolver to resolve the spec directory:
   ```javascript
   const { resolveSpecPath } = require(".claude/scripts/lib/spec-resolver.cjs");
   const { path: specPath, type, name } = resolveSpecPath(feature);
   // specPath is absolute with trailing slash
   // type is 'project'|'feature'|'spec'
   // name is normalized feature name
   ```
2. **Check spec exists** - Resolver throws if spec not found (no manual check needed)
3. **Read summary (optional)** - If `${specPath}summary.md` exists:
   - Read the file and extract the one-paragraph summary (text between `## Summary` and `---`)
   - Pass summary as initial context to researcher sub-agent (as `SUMMARY:` field in prompt)
   - Display summary in preview CONTEXT section as `Summary: {first_sentence}...`
   - If absent, skip this step (no error)
4. **Read spec.json (optional)** - If `${specPath}spec.json` exists:
   - Parse JSON and use `spec.json.phases` array for phase enumeration instead of parsing tasks.md section headers
   - Use `spec.json.tasks` array for task listing (id, title, status, assignee)
   - If `spec.json.linear.identifier` exists, include it in checkpoint data and progress output (e.g., "Linear: BASE-123")
   - If absent, use task-parser as alternative (no error)
   - **Note:** `spec.json` is authoritative when present, with `tasks.md` as fallback alternative
5. **Parse tasks** - Use task-parser.parseTasks() to get structured tasks (if spec.json not available)
6. **Load checkpoint** - If --resume, load .claude/state/implement-{feature}.json
7. **Merge status** - Merge checkpoint status with parsed tasks
8. **Apply filters** - Filter tasks based on --task or --phase flags
9. **Route agents** - Analyze tasks to determine which agents needed
10. **Show preview** - Display unified preview with PROGRESS section
11. **Save pre-checkpoint** - Save initial checkpoint before first task
12. **Execute tasks** - For each task:

- Route to appropriate agent (code/ui/docs/eval)
- Update checkpoint with task completion
- Update tasks.md checkbox

13. **Verify** - Run quality checks (lint, typecheck, tests)
14. **Complete checkpoint** - Mark checkpoint as complete and report

## Routing Logic

Based on spec content:

| Spec Content                       | Routes To          |
| ---------------------------------- | ------------------ |
| Backend tasks (tRPC, Prisma, API)  | code-agent         |
| Frontend tasks (React, components) | ui-agent           |
| Documentation tasks                | docs-agent         |
| Evaluation tasks                   | eval-agent         |
| Mixed (backend + frontend)         | implement workflow |

## Task Filtering

**--task flag:**

- Single: `--task=T001` executes only T001
- Multiple: `--task=T001,T002,T003` executes specified tasks
- Range: `--task=T001-T005` executes T001 through T005

**--phase flag:**

- Single: `--phase=1` executes all tasks in phase 1
- Multiple: `--phase=1,2` executes all tasks in phases 1 and 2
- Plus: `--phase=2+` executes phase 2 and all subsequent phases

**Flag combinations:**

- `--task` overrides `--phase` (most granular wins)
- `--resume --task=T005` resumes but only executes T005+
- `--resume --phase=2` resumes but only executes phase 2 tasks

## Checkpoint Recovery

When --resume is used:

1. Load checkpoint from .claude/state/implement-{feature}.json
2. Validate checkpoint schema version (must be 1)
3. Check head_commit for staleness (warn if different)
4. Merge checkpoint task status with parsed tasks
5. Find first task with status !== 'complete'
6. Resume execution from that task
7. Skip all previously completed tasks

**Light Pre-Checkpoint:**
Before executing the first task, a light checkpoint is saved containing all tasks with status from tasks.md. This enables recovery even if the first task fails.

If checkpoint doesn't exist, report error and suggest running without --resume.

## Checkpoint Integration

The orchestrating agent uses checkpoint-manager.cjs to track progress across all tasks.

### Step 3: Load Checkpoint (--resume)

```javascript
const {
  loadCheckpoint,
} = require(".claude/scripts/lib/checkpoint-manager.cjs");
const checkpoint = loadCheckpoint("implement", feature);

if (!checkpoint) {
  throw new Error("Checkpoint not found. Run without --resume to start fresh.");
}

// Validate schema version
if (checkpoint.version !== 1) {
  throw new Error(`Unsupported checkpoint version: ${checkpoint.version}`);
}

// Warn if head_commit differs (stale checkpoint)
const currentCommit = execSync("git rev-parse HEAD").toString().trim();
if (checkpoint.head_commit !== currentCommit) {
  console.warn("Warning: Checkpoint was created at a different commit.");
  console.warn(`Checkpoint: ${checkpoint.head_commit}`);
  console.warn(`Current: ${currentCommit}`);
}
```

### Step 4: Merge Checkpoint Status with Parsed Tasks

```javascript
// After parsing tasks with task-parser.parseTasks()
for (const phase of parsedTasks.phases) {
  const phaseKey = `phase-${phase.number}`;
  const checkpointPhase = checkpoint?.phases?.[phaseKey];

  if (checkpointPhase) {
    for (const task of phase.tasks) {
      const checkpointTask = checkpointPhase.tasks?.[task.id];
      if (checkpointTask?.status === "complete") {
        task.status = "complete";
      }
    }
  }
}

// Find first incomplete task
const firstIncomplete = parsedTasks.phases
  .flatMap((p) => p.tasks)
  .find((t) => t.status !== "complete");
```

### Step 8: Save Pre-Checkpoint (Before First Task)

```javascript
const {
  saveCheckpoint,
} = require(".claude/scripts/lib/checkpoint-manager.cjs");
const { execSync } = require("child_process");

// Build initial checkpoint structure
const initialCheckpoint = {
  version: 1,
  command: "implement",
  feature,
  spec_path: specPath,
  head_commit: execSync("git rev-parse HEAD").toString().trim(),
  state: {
    current_phase: null,
    completed_phases: [],
    pending_phases: parsedTasks.phases.map((p) => `phase-${p.number}`),
  },
  phases: {},
};

// Populate phases from parsed tasks
for (const phase of parsedTasks.phases) {
  const phaseKey = `phase-${phase.number}`;
  initialCheckpoint.phases[phaseKey] = {
    status: "pending",
    tasks: {},
  };

  for (const task of phase.tasks) {
    initialCheckpoint.phases[phaseKey].tasks[task.id] = {
      status: task.status || "pending",
      description: task.description,
    };
  }
}

// Save checkpoint before execution starts
saveCheckpoint("implement", initialCheckpoint, feature);
```

### Step 9: Update Checkpoint Per Task

```javascript
const { updatePhase } = require(".claude/scripts/lib/checkpoint-manager.cjs");
const { updateTaskCheckbox } = require(".claude/scripts/lib/task-parser.cjs");

// After a task completes successfully
const phaseKey = `phase-${phase.number}`;
const taskId = task.id;

// Update checkpoint
updatePhase(
  "implement",
  phaseKey,
  {
    status: "in_progress",
    tasks: {
      [taskId]: { status: "complete" },
    },
  },
  feature
);

// Update tasks.md checkbox
const tasksPath = `${specPath}tasks.md`;
updateTaskCheckbox(tasksPath, taskId, true);

// If all tasks in phase complete, mark phase complete
const allComplete = phase.tasks.every((t) => t.status === "complete");
if (allComplete) {
  updatePhase(
    "implement",
    phaseKey,
    {
      status: "complete",
    },
    feature
  );
}
```

### Step 11: Complete Checkpoint

```javascript
const {
  completeCheckpoint,
} = require(".claude/scripts/lib/checkpoint-manager.cjs");

// After all tasks complete successfully
completeCheckpoint("implement", feature);

// This moves checkpoint to .completed/ archive
```

### Checkpoint State Schema

```json
{
  "version": 1,
  "command": "implement",
  "feature": "user-authentication",
  "spec_path": "/home/user/project/specs/user-authentication/",
  "head_commit": "abc123def456...",
  "state": {
    "current_phase": "phase-2",
    "completed_phases": ["phase-1"],
    "pending_phases": ["phase-3", "phase-4"]
  },
  "phases": {
    "phase-1": {
      "status": "complete",
      "tasks": {
        "T001": { "status": "complete", "description": "Create User model" },
        "T002": { "status": "complete", "description": "Create migration" }
      }
    },
    "phase-2": {
      "status": "in_progress",
      "tasks": {
        "T003": { "status": "complete", "description": "Create router" },
        "T004": { "status": "pending", "description": "Implement login" }
      }
    }
  }
}
```

## Preview

**Template:** Read `.claude/skills/preview/templates/command-preview.md` for base layout.

**Variables:**

| Variable                | Value                                           |
| ----------------------- | ----------------------------------------------- |
| `{{command}}`           | `implement`                                     |
| `{{description}}`       | Build Approved Spec                             |
| `{{dir}}`               | Working directory                               |
| `{{branch}}`            | Current git branch                              |
| `{{feature}}`           | Feature name from spec                          |
| `{{spec_path}}`         | Resolved spec path from spec-resolver           |
| `{{checkpoint}}`        | `.claude/state/implement-{{feature}}.json`      |
| `{{first_sentence}}`    | First sentence from summary.md (if available)   |
| `{{linear_identifier}}` | Linear issue ID from spec.json (if available)   |
| `{{total}}`             | Total task count from parsed tasks or spec.json |
| `{{completed}}`         | Number of tasks with status `complete`          |
| `{{phase_count}}`       | Number of phases                                |
| `{{phase_name}}`        | Phase title (per phase)                         |
| `{{phase_done}}`        | Completed tasks in phase (per phase)            |
| `{{phase_total}}`       | Total tasks in phase (per phase)                |
| `{{task_description}}`  | Task description from tasks.md (per task)       |
| `{{stage_name}}`        | Stage name derived from phase grouping          |
| `{{research_tasks}}`    | Brief description of research steps             |
| `{{test_tasks}}`        | Brief description of test-writing steps         |
| `{{impl_tasks}}`        | Brief description of implementation steps       |

**CONTEXT section** (extends template lines 15-20):

```text
│ CONTEXT                                                              │
│   Spec: {{spec_path}} (resolved)                                     │
│   Summary: {{first_sentence}}...                                     │
│   Tasks: {{total}} across {{phase_count}} phases                     │
│   Linear: {{linear_identifier}} (if available)                       │
│   TDD: Enabled (red → green → refactor)                             │
│   Checkpoint: {{checkpoint}}                                         │
```

**PROGRESS section** (extends template lines 48-51):

Per-task breakdown grouped by phase, showing completion status per task:

```text
│ PROGRESS                                                             │
│   Tasks: {{completed}}/{{total}} complete                            │
│                                                                      │
│   Phase 1: {{phase_name}} ({{phase_done}}/{{phase_total}})           │
│   ✓ T001 {{task_description}}                                       │
│   ✓ T002 {{task_description}}                                       │
│                                                                      │
│   Phase 2: {{phase_name}} ({{phase_done}}/{{phase_total}})           │
│   ● T003 {{task_description}}                    [CURRENT]          │
│   ○ T004 {{task_description}}                                       │
```

**STAGES section** (extends template lines 22-25):

Each stage contains nested TDD phases with sub-agent and model assignments:

```text
│ STAGES                                                               │
│   1. {{stage_name}} (code-agent)                                     │
│      1. RESEARCH      code-researcher / Opus                         │
│         → {{research_tasks}}                                         │
│      2. TDD-RED       code-writer / Sonnet                           │
│         → {{test_tasks}}                                             │
│      3. TDD-GREEN     code-writer / Sonnet                           │
│         → {{impl_tasks}}                                             │
│      4. VALIDATE      code-validator / Haiku                         │
│         → Verify tests pass                                          │
│                                                                      │
│   N. FINAL VERIFICATION (check-agent / parallel)                     │
│      ⊕ build-checker                                                 │
│      ⊕ type-checker                                                  │
│      ⊕ lint-checker                                                  │
│      ⊕ test-runner                                                   │
│      ⊕ security-scanner                                              │
```

**Rendering steps:**

1. Read `command-preview.md` template
2. Fill variables from parsed spec/tasks/checkpoint
3. Render CONTEXT, PROGRESS, and STAGES sections
4. Use AskUserQuestion tool to confirm: Run / Cancel

**Legend:**

- ✓ = Complete
- ● = Current (next to execute)
- ○ = Pending

## Progress Display

**Template:** Read `.claude/skills/progress/templates/stage-progress.md` for base layout and Unicode indicators.

During execution, render progress using the stage-progress template. Each stage maps to a TDD phase within the current implementation task.

**TDD phase labels:**

| Phase | Label         | Sub-agent       | Model  |
| ----- | ------------- | --------------- | ------ |
| 1     | `[RESEARCH]`  | code-researcher | Opus   |
| 2     | `[TDD-RED]`   | code-writer     | Sonnet |
| 3     | `[TDD-GREEN]` | code-writer     | Sonnet |
| 4     | `[VALIDATE]`  | code-validator  | Haiku  |

**Example** (multi-stage structure per template format):

```text
/implement - Build Approved Spec

Stage 1/3: DATABASE SCHEMA
  ● Running: code-writer (Sonnet)
  ├── Writing failing tests for User model...
  └── Elapsed: 4.2s

[============                    ] 33% | Stage 1/3 | 6.3s elapsed

Stage Status:
  ✓ Stage 1.1: RESEARCH (complete)
  ● Stage 1.2: TDD-RED (running)
  ○ Stage 1.3: TDD-GREEN (pending)
  ○ Stage 1.4: VALIDATE (pending)
```

**Update frequency:** Render progress after each sub-agent completes within a stage. See `stage-progress.md` for Unicode indicators (✓ ● ○ ✗ ⊘).

## Output

```text
Implementation complete!

Files created:
  • prisma/migrations/..._add_user.sql
  • src/lib/user.ts
  • src/lib/auth.ts
  • src/server/routers/auth.ts
  • + 5 test files

Verification:
  ✓ Build:    PASS
  ✓ Types:    PASS (0 errors)
  ✓ Lint:     PASS (0 errors)
  ✓ Tests:    PASS (23/23, 87% coverage)
  ✓ Security: PASS

Run /ship when ready to create PR.
```

## TDD Workflow

For each implementation task:

1. **RED**: Write failing test that describes expected behavior
2. **GREEN**: Write minimal code to make test pass
3. **REFACTOR**: Clean up while keeping tests green

## Final Verification

Always includes (parallel execution):

- Build check (`pnpm build`)
- Type check (`pnpm typecheck`)
- Lint check (`pnpm lint`)
- Test run (`pnpm test:run`)
- Security scan (`pnpm audit`)

## Mode Behavior

| Mode  | Preview | Sub-agents | TDD | Verification |
| ----- | ------- | ---------- | --- | ------------ |
| dev   | Yes     | Yes        | Yes | Yes          |
| basic | No      | No         | Yes | Yes          |

## Error Handling

**Template:** Read `.claude/skills/preview/templates/error-report.md` for error display format.

All errors during execution should be rendered using the error-report template.

**Variable mappings for /implement errors:**

| Variable              | Value                                                                             |
| --------------------- | --------------------------------------------------------------------------------- |
| `{{stage_name}}`      | Which stage failed: RESEARCH, TDD-RED, TDD-GREEN, VALIDATE, VERIFICATION          |
| `{{sub_agent}}`       | Which sub-agent failed: code-researcher, code-writer, code-validator, check-agent |
| `{{model}}`           | Model of the failed sub-agent: Opus, Sonnet, Haiku                                |
| `{{message}}`         | Error message from the failed operation                                           |
| `{{file_line}}`       | File and line number where error occurred (if applicable)                         |
| `{{option_1}}`        | Primary recovery option (e.g., "Fix and re-run: `/implement --resume`")           |
| `{{option_2}}`        | Alternative recovery option (e.g., "Run without checkpoint: `/implement`")        |
| `{{option_3}}`        | Fallback option (e.g., "Investigate: check error details above")                  |
| `{{checkpoint_path}}` | `.claude/state/implement-{{feature}}.json`                                        |
| `{{resume_cmd}}`      | `/implement --resume`                                                             |

**Error scenarios and recovery:**

| Scenario             | Handling                                      | Recovery                                       |
| -------------------- | --------------------------------------------- | ---------------------------------------------- |
| No approved spec     | Error: Run /design first                      | Run `/design` then `/implement`                |
| Invalid task ID      | Error: List available task IDs                | Re-run with valid `--task` flag                |
| Invalid phase number | Error: List available phases                  | Re-run with valid `--phase` flag               |
| Empty filter result  | Error: Explain why no tasks matched           | Adjust filter flags                            |
| Checkpoint missing   | Error: Cannot --resume without checkpoint     | Run without `--resume`                         |
| Checkpoint stale     | Warning: head_commit differs, continue anyway | Re-run without `--resume` for clean start      |
| Schema mismatch      | Error: Checkpoint version !== 1               | Delete checkpoint, run without `--resume`      |
| Test failures        | Report and stop                               | Fix failing tests and `/implement --resume`    |
| Build failures       | Report with error details                     | Check build errors, fix, `/implement --resume` |
| Type errors          | Report with file/line info                    | Fix type errors, `/implement --resume`         |
| Security issues      | Report severity and suggestions               | Address findings, `/implement --resume`        |

## Skills Used

- `routing` - Determine which agents needed
- `preview` - Show execution plan
- `progress` - Real-time status display
- `tdd-workflow` - Red-Green-Refactor cycle
- `qa-checks` - Final verification

## After /implement

1. Review the files created
2. Run `/ship` to commit and create PR
3. Or run `/guide` to see current status

$ARGUMENTS
