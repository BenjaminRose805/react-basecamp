name: Spec Validation

on:
  workflow_call:
    inputs:
      specs-directory:
        description: "Directory containing spec files"
        type: string
        default: "specs/"
      require-spec-for-features:
        description: "Require specs for feature branches"
        type: boolean
        default: true
      spec-template-path:
        description: "Path to spec template for validation"
        type: string
        default: ""
      feature-branch-pattern:
        description: "Regex pattern for feature branch names"
        type: string
        default: "^(feature|feat)/"

jobs:
  validate-specs:
    name: Validate Specs
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if feature branch
        id: branch-check
        run: |
          BRANCH="${{ github.head_ref || github.ref_name }}"
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT

          if echo "$BRANCH" | grep -qE '${{ inputs.feature-branch-pattern }}'; then
            echo "is_feature=true" >> $GITHUB_OUTPUT
            echo "This is a feature branch: $BRANCH"
          else
            echo "is_feature=false" >> $GITHUB_OUTPUT
            echo "Not a feature branch: $BRANCH"
          fi

      - name: Find related spec directory
        id: find-spec
        run: |
          BRANCH="${{ steps.branch-check.outputs.branch }}"
          SPECS_DIR="${{ inputs.specs-directory }}"

          # Extract feature name from branch
          # Supports: feature/user-auth, feat/project-feature, feat-project-feature-specs
          FEATURE_NAME=$(echo "$BRANCH" | sed -E 's/^(feature|feat)[\/\-]//' | sed 's/-specs$//' | sed 's/\//-/g')

          echo "Looking for spec related to: $FEATURE_NAME"

          # T004: Recursive meta.yaml discovery (informational - shows all specs)
          echo "Available specs (recursive discovery):"
          if [ -d "$SPECS_DIR" ]; then
            # Recursively find all meta.yaml files to discover nested spec directories
            find "$SPECS_DIR" -type f -name 'meta.yaml' 2>/dev/null | while read -r meta_file; do
              spec_path=$(dirname "$meta_file")
              echo "  - $spec_path"
            done
          fi

          # T006: Enhanced branch-to-path mapping with nested path support
          # Note: Dash-separated branch names create ambiguity for nested paths.
          # Example: 'design-hierarchy-downstream' could map to either:
          #   - Nested: specs/design/hierarchy/ (project=design, feature=hierarchy)
          #   - Flat: specs/design-hierarchy-downstream/ (feature=design-hierarchy-downstream)
          # Resolution strategy: Try nested path first (specs/{first-part}/{second-part}/);
          # if not found, fall back to flat path (specs/{entire-name}/). The flat fallback
          # handles most cases correctly, including features with multi-dash names.
          SPEC_DIR=""
          if [ -d "$SPECS_DIR" ]; then
            # Parse potential project/feature structure from branch name
            # Try patterns: {prefix}-{project}-{feature}, {prefix}/{project}/{feature}, etc.
            IFS='-' read -ra PARTS <<< "$FEATURE_NAME"

            if [ ${#PARTS[@]} -ge 2 ]; then
              # Try nested path first: specs/{project}/{feature}/
              NESTED_PATH="${SPECS_DIR}${PARTS[0]}/${PARTS[1]}"
              if [ -d "$NESTED_PATH" ]; then
                SPEC_DIR="$NESTED_PATH"
                echo "Found nested spec directory: $SPEC_DIR"
              fi
            fi

            # Fall back to flat structure if nested not found
            if [ -z "$SPEC_DIR" ]; then
              FLAT_PATH="${SPECS_DIR}${FEATURE_NAME}"
              if [ -d "$FLAT_PATH" ]; then
                SPEC_DIR="$FLAT_PATH"
                echo "Found flat spec directory: $SPEC_DIR"
              else
                # Legacy: Look for directory matching feature name (partial match)
                SPEC_DIR=$(find "$SPECS_DIR" -type d -name "*${FEATURE_NAME}*" 2>/dev/null | head -1)
                [ -n "$SPEC_DIR" ] && echo "Found spec directory (partial match): $SPEC_DIR"
              fi
            fi
          fi

          if [ -n "$SPEC_DIR" ] && [ -d "$SPEC_DIR" ]; then
            echo "spec_found=true" >> $GITHUB_OUTPUT
            echo "spec_dir=$SPEC_DIR" >> $GITHUB_OUTPUT

            # T005: Detect spec level by checking for project.md or feature.md
            SPEC_LEVEL="STANDALONE"
            if [ -f "$SPEC_DIR/project.md" ]; then
              SPEC_LEVEL="PROJECT"
            elif [ -f "$SPEC_DIR/feature.md" ]; then
              SPEC_LEVEL="FEATURE"
            fi
            echo "spec_level=$SPEC_LEVEL" >> $GITHUB_OUTPUT
            echo "Detected spec level: $SPEC_LEVEL"

            # T005: Check for required files based on level
            case "$SPEC_LEVEL" in
              PROJECT)
                [ -f "$SPEC_DIR/project.md" ] && echo "has_project=true" >> $GITHUB_OUTPUT || echo "has_project=false" >> $GITHUB_OUTPUT
                [ -f "$SPEC_DIR/requirements.md" ] && echo "has_requirements=true" >> $GITHUB_OUTPUT || echo "has_requirements=false" >> $GITHUB_OUTPUT
                [ -f "$SPEC_DIR/meta.yaml" ] && echo "has_meta=true" >> $GITHUB_OUTPUT || echo "has_meta=false" >> $GITHUB_OUTPUT
                ;;
              FEATURE)
                [ -f "$SPEC_DIR/feature.md" ] && echo "has_feature=true" >> $GITHUB_OUTPUT || echo "has_feature=false" >> $GITHUB_OUTPUT
                [ -f "$SPEC_DIR/requirements.md" ] && echo "has_requirements=true" >> $GITHUB_OUTPUT || echo "has_requirements=false" >> $GITHUB_OUTPUT
                [ -f "$SPEC_DIR/design.md" ] && echo "has_design=true" >> $GITHUB_OUTPUT || echo "has_design=false" >> $GITHUB_OUTPUT
                [ -f "$SPEC_DIR/tasks.md" ] && echo "has_tasks=true" >> $GITHUB_OUTPUT || echo "has_tasks=false" >> $GITHUB_OUTPUT
                [ -f "$SPEC_DIR/meta.yaml" ] && echo "has_meta=true" >> $GITHUB_OUTPUT || echo "has_meta=false" >> $GITHUB_OUTPUT
                [ -f "$SPEC_DIR/summary.md" ] && echo "has_summary=true" >> $GITHUB_OUTPUT || echo "has_summary=false" >> $GITHUB_OUTPUT
                [ -f "$SPEC_DIR/spec.json" ] && echo "has_spec_json=true" >> $GITHUB_OUTPUT || echo "has_spec_json=false" >> $GITHUB_OUTPUT
                ;;
              STANDALONE)
                [ -f "$SPEC_DIR/requirements.md" ] && echo "has_requirements=true" >> $GITHUB_OUTPUT || echo "has_requirements=false" >> $GITHUB_OUTPUT
                [ -f "$SPEC_DIR/design.md" ] && echo "has_design=true" >> $GITHUB_OUTPUT || echo "has_design=false" >> $GITHUB_OUTPUT
                [ -f "$SPEC_DIR/tasks.md" ] && echo "has_tasks=true" >> $GITHUB_OUTPUT || echo "has_tasks=false" >> $GITHUB_OUTPUT
                [ -f "$SPEC_DIR/meta.yaml" ] && echo "has_meta=true" >> $GITHUB_OUTPUT || echo "has_meta=false" >> $GITHUB_OUTPUT
                [ -f "$SPEC_DIR/summary.md" ] && echo "has_summary=true" >> $GITHUB_OUTPUT || echo "has_summary=false" >> $GITHUB_OUTPUT
                [ -f "$SPEC_DIR/spec.json" ] && echo "has_spec_json=true" >> $GITHUB_OUTPUT || echo "has_spec_json=false" >> $GITHUB_OUTPUT
                ;;
            esac
          else
            echo "No spec directory found for feature: $FEATURE_NAME"
            echo "spec_found=false" >> $GITHUB_OUTPUT
            echo "spec_dir=" >> $GITHUB_OUTPUT
            echo "spec_level=" >> $GITHUB_OUTPUT
          fi

      - name: Validate spec files
        if: steps.find-spec.outputs.spec_found == 'true'
        id: validate-spec
        run: |
          SPEC_DIR="${{ steps.find-spec.outputs.spec_dir }}"
          SPEC_LEVEL="${{ steps.find-spec.outputs.spec_level }}"
          ERRORS=""
          WARNINGS=""

          echo "Validating specs in: $SPEC_DIR (Level: $SPEC_LEVEL)"

          # T005: Level-based validation with required files per level
          case "$SPEC_LEVEL" in
            PROJECT)
              # PROJECT level: project.md, requirements.md, meta.yaml
              [ ! -f "$SPEC_DIR/project.md" ] && ERRORS="$ERRORS\n- [$SPEC_LEVEL] Missing required file: project.md"
              [ ! -f "$SPEC_DIR/requirements.md" ] && ERRORS="$ERRORS\n- [$SPEC_LEVEL] Missing required file: requirements.md"
              [ ! -f "$SPEC_DIR/meta.yaml" ] && ERRORS="$ERRORS\n- [$SPEC_LEVEL] Missing required file: meta.yaml"
              ;;
            FEATURE)
              # FEATURE level: feature.md, requirements.md, design.md, tasks.md, meta.yaml, summary.md, spec.json
              [ ! -f "$SPEC_DIR/feature.md" ] && ERRORS="$ERRORS\n- [$SPEC_LEVEL] Missing required file: feature.md"
              [ ! -f "$SPEC_DIR/requirements.md" ] && ERRORS="$ERRORS\n- [$SPEC_LEVEL] Missing required file: requirements.md"
              [ ! -f "$SPEC_DIR/design.md" ] && ERRORS="$ERRORS\n- [$SPEC_LEVEL] Missing required file: design.md"
              [ ! -f "$SPEC_DIR/tasks.md" ] && ERRORS="$ERRORS\n- [$SPEC_LEVEL] Missing required file: tasks.md"
              [ ! -f "$SPEC_DIR/meta.yaml" ] && ERRORS="$ERRORS\n- [$SPEC_LEVEL] Missing required file: meta.yaml"
              [ ! -f "$SPEC_DIR/summary.md" ] && ERRORS="$ERRORS\n- [$SPEC_LEVEL] Missing required file: summary.md"
              [ ! -f "$SPEC_DIR/spec.json" ] && ERRORS="$ERRORS\n- [$SPEC_LEVEL] Missing required file: spec.json"
              ;;
            STANDALONE)
              # STANDALONE level: requirements.md, design.md, tasks.md, meta.yaml, summary.md, spec.json
              [ ! -f "$SPEC_DIR/requirements.md" ] && ERRORS="$ERRORS\n- [$SPEC_LEVEL] Missing required file: requirements.md"
              [ ! -f "$SPEC_DIR/design.md" ] && ERRORS="$ERRORS\n- [$SPEC_LEVEL] Missing required file: design.md"
              [ ! -f "$SPEC_DIR/tasks.md" ] && ERRORS="$ERRORS\n- [$SPEC_LEVEL] Missing required file: tasks.md"
              [ ! -f "$SPEC_DIR/meta.yaml" ] && ERRORS="$ERRORS\n- [$SPEC_LEVEL] Missing required file: meta.yaml"
              [ ! -f "$SPEC_DIR/summary.md" ] && ERRORS="$ERRORS\n- [$SPEC_LEVEL] Missing required file: summary.md"
              [ ! -f "$SPEC_DIR/spec.json" ] && ERRORS="$ERRORS\n- [$SPEC_LEVEL] Missing required file: spec.json"
              ;;
          esac

          # Validate requirements.md content (if present)
          if [ -f "$SPEC_DIR/requirements.md" ]; then
            echo "Validating requirements.md..."
            REQUIRED_SECTIONS=("Goal" "User Stories" "Success Criteria" "Technical Constraints" "Out of Scope")
            for section in "${REQUIRED_SECTIONS[@]}"; do
              if ! grep -qi "^##.*$section" "$SPEC_DIR/requirements.md"; then
                ERRORS="$ERRORS\n- requirements.md: Missing section: $section"
              fi
            done

            # Check for success criteria checkboxes
            if ! grep -qE '^\s*-\s*\[[ x]\]' "$SPEC_DIR/requirements.md"; then
              WARNINGS="$WARNINGS\n- requirements.md: Success criteria should use checkboxes"
            fi

            # Recommended sections
            for section in "Dependencies" "Risks"; do
              if ! grep -qi "^##.*$section" "$SPEC_DIR/requirements.md"; then
                WARNINGS="$WARNINGS\n- requirements.md: Consider adding section: $section"
              fi
            done
          fi

          # Validate design.md content (if present)
          if [ -f "$SPEC_DIR/design.md" ]; then
            echo "Validating design.md..."
            DESIGN_SECTIONS=("Overview" "Architecture" "Component Design")
            for section in "${DESIGN_SECTIONS[@]}"; do
              if ! grep -qi "^##.*$section" "$SPEC_DIR/design.md"; then
                WARNINGS="$WARNINGS\n- design.md: Consider adding section: $section"
              fi
            done
          fi

          # Validate tasks.md content (if present)
          if [ -f "$SPEC_DIR/tasks.md" ]; then
            echo "Validating tasks.md..."
            TASKS_SECTIONS=("Progress" "Phase")
            for section in "${TASKS_SECTIONS[@]}"; do
              if ! grep -qi "^##.*$section" "$SPEC_DIR/tasks.md"; then
                WARNINGS="$WARNINGS\n- tasks.md: Consider adding section: $section"
              fi
            done

            # Check for task checkboxes
            if ! grep -qE '^\s*-\s*\[[ x]\]' "$SPEC_DIR/tasks.md"; then
              WARNINGS="$WARNINGS\n- tasks.md: Tasks should use checkboxes"
            fi
          fi

          if [ -n "$ERRORS" ]; then
            echo "valid=false" >> $GITHUB_OUTPUT
            echo "errors<<EOF" >> $GITHUB_OUTPUT
            echo -e "$ERRORS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "valid=true" >> $GITHUB_OUTPUT
            echo "errors=" >> $GITHUB_OUTPUT
          fi

          echo "warnings<<EOF" >> $GITHUB_OUTPUT
          echo -e "$WARNINGS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Post validation results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const isFeature = '${{ steps.branch-check.outputs.is_feature }}' === 'true';
            const specFound = '${{ steps.find-spec.outputs.spec_found }}' === 'true';
            const specDir = '${{ steps.find-spec.outputs.spec_dir }}';
            const specLevel = '${{ steps.find-spec.outputs.spec_level }}';
            const specValid = '${{ steps.validate-spec.outputs.valid }}' === 'true';
            const errors = `${{ steps.validate-spec.outputs.errors }}`;
            const warnings = `${{ steps.validate-spec.outputs.warnings }}`;
            const requireSpec = '${{ inputs.require-spec-for-features }}' === 'true';

            // T005: Get level-specific file checks
            const hasProject = '${{ steps.find-spec.outputs.has_project }}' === 'true';
            const hasFeature = '${{ steps.find-spec.outputs.has_feature }}' === 'true';
            const hasRequirements = '${{ steps.find-spec.outputs.has_requirements }}' === 'true';
            const hasDesign = '${{ steps.find-spec.outputs.has_design }}' === 'true';
            const hasTasks = '${{ steps.find-spec.outputs.has_tasks }}' === 'true';
            const hasMeta = '${{ steps.find-spec.outputs.has_meta }}' === 'true';
            const hasSummary = '${{ steps.find-spec.outputs.has_summary }}' === 'true';
            const hasSpecJson = '${{ steps.find-spec.outputs.has_spec_json }}' === 'true';

            let body = '## ğŸ“‹ Spec Validation\n\n';

            if (!isFeature) {
              body += 'âœ… Not a feature branch - spec not required.\n';
            } else if (specFound) {
              // T007: Use full spec directory path in PR comment
              body += `âœ… Found spec at: \`${specDir}\`\n`;
              body += `ğŸ“ Level: **${specLevel}**\n\n`;
              body += '**Files found:**\n';

              // T005: Display required files based on level
              if (specLevel === 'PROJECT') {
                body += `- project.md: ${hasProject ? 'âœ…' : 'âŒ (required)'}\n`;
                body += `- requirements.md: ${hasRequirements ? 'âœ…' : 'âŒ (required)'}\n`;
                body += `- meta.yaml: ${hasMeta ? 'âœ…' : 'âŒ (required)'}\n`;
              } else if (specLevel === 'FEATURE') {
                body += `- feature.md: ${hasFeature ? 'âœ…' : 'âŒ (required)'}\n`;
                body += `- requirements.md: ${hasRequirements ? 'âœ…' : 'âŒ (required)'}\n`;
                body += `- design.md: ${hasDesign ? 'âœ…' : 'âŒ (required)'}\n`;
                body += `- tasks.md: ${hasTasks ? 'âœ…' : 'âŒ (required)'}\n`;
                body += `- meta.yaml: ${hasMeta ? 'âœ…' : 'âŒ (required)'}\n`;
                body += `- summary.md: ${hasSummary ? 'âœ…' : 'âŒ (required)'}\n`;
                body += `- spec.json: ${hasSpecJson ? 'âœ…' : 'âŒ (required)'}\n`;
              } else { // STANDALONE
                body += `- requirements.md: ${hasRequirements ? 'âœ…' : 'âŒ (required)'}\n`;
                body += `- design.md: ${hasDesign ? 'âœ…' : 'âŒ (required)'}\n`;
                body += `- tasks.md: ${hasTasks ? 'âœ…' : 'âŒ (required)'}\n`;
                body += `- meta.yaml: ${hasMeta ? 'âœ…' : 'âŒ (required)'}\n`;
                body += `- summary.md: ${hasSummary ? 'âœ…' : 'âŒ (required)'}\n`;
                body += `- spec.json: ${hasSpecJson ? 'âœ…' : 'âŒ (required)'}\n`;
              }

              body += '\n';

              if (specValid) {
                // T007: Include path in success message
                body += `âœ… Spec at \`${specDir}\` is valid.\n`;
              } else {
                // T007: Include path in failure message
                body += `âŒ Spec at \`${specDir}\` has issues:\n` + errors + '\n';
              }

              if (warnings && warnings.trim()) {
                body += '\nâš ï¸ Suggestions:\n' + warnings + '\n';
              }
            } else {
              if (requireSpec) {
                body += 'âŒ No spec directory found for this feature branch.\n\n';
                body += 'Please create a spec directory in `${{ inputs.specs-directory }}{feature-name}/` or `${{ inputs.specs-directory }}{project}/{feature}/`.\n';
              } else {
                body += 'âš ï¸ No spec directory found for this feature branch.\n\n';
                body += 'Consider creating a spec directory in `${{ inputs.specs-directory }}{feature-name}/` or `${{ inputs.specs-directory }}{project}/{feature}/`.\n';
              }
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });

      - name: Fail if spec required but missing
        if: |
          inputs.require-spec-for-features &&
          steps.branch-check.outputs.is_feature == 'true' &&
          steps.find-spec.outputs.spec_found == 'false'
        run: |
          echo "::error::Feature branch requires a spec file"
          exit 1

      - name: Fail if spec invalid
        if: |
          steps.find-spec.outputs.spec_found == 'true' &&
          steps.validate-spec.outputs.valid == 'false'
        run: |
          echo "::error::Spec file has format issues"
          exit 1
